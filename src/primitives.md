# Простейшие

Ржавчина предоставляет доступ к большому количеству `простейших`:

### Одиночные виды

- знаковые целочисленные: `i8`, `i16`, `i32`, `i64` и `isize` (размер указателя)
- беззнаковые целочисленные: `u8`, `u16`, `u32`, `u64` и `usize` (размер указателя)
- вещественные: `f32`, `f64`
- `char` одиночное значение Unicode, например: `'a'`, `'α'` и `'∞'` (4 байта каждый)
- `bool`: `true` или `false`
- единичный вид `()`, значение которого так же `()`

Несмотря на то, что значение единичного вида является упорядоченным рядом, оно не считается
составным видом, потому что не содержит нескольких значений.

### Составные виды

- массивы, например `[1, 2, 3]`
- упорядоченные ряды, например `(1, true)`

Переменные всегда должны быть *изложены*.
Числам можно указать определённый вид с помощью *вставки*,
иначе будет присвоен *вид по умолчанию*.
Целочисленные значения по умолчанию `i32`, а вещественные `f64`.
Стоит заметить, что Ржавчина также умеет выводить виды из окружения.

```rust,editable,ignore,mdbook-runnable
fn main() {
    // Переменные могут быть изложены.
    let logical: bool = true;

    let a_float: f64 = 1.0;  // Обычная изложение
    let an_integer   = 5i32; // Вставная изложение

    // Этим переменным будет присвоен вид по умолчанию.
    let default_float   = 3.0; // `f64`
    let default_integer = 7;   // `i32`
    
    // вид также может быть выведен из окружения.
    let mut inferred_type = 12; // вид i64 выводится из другой строки
    inferred_type = 4294967296i64;
    
    // Значение изменяемой переменной может быть изменено.
    let mut mutable = 12; // Изменяемое `i32`
    mutable = 21;
    
    // Ошибка! вид переменной изменить нельзя.
    mutable = true;
    
    // Переменные могут быть переопределены с помощью затенения.
    let mutable = true;
}
```

### Смотрите также:

[встроенная библиотека (`std`)](https://doc.rust-lang.org/std/), [`mut`](variable_bindings/mut.md), [вывод видов](types/inference.md) и [затенение](variable_bindings/scope.md)
