# Обобщения

*Обобщения* позволяют обобщить виды и возможности для более общих случаев. Они
чрезвычайно полезны благодаря уменьшению дублирования рукописи, однако могут привести к
сравнительному усложнению правил написания. А именно, использование обобщений требует особого
внимания при определении допустимых реальных видов которыми могут заменяться обобщённые.
Наиболее простым и распространённым применением обобщений является обобщение параметров
вида.

Обобщить параметр вида можно используя угловые скобки и верхний [верблюжий регистр](https://en.wikipedia.org/wiki/CamelCase):
`<Aaa, Bbb, ...>`. "Обобщённые параметры вида" обычно представлены как `<T>`. В Ржавчине,
"обобщённым" также принято называть все, что может принимать один или более обобщённых
параметров вида `<T>`. Любой вид, указанный в качестве параметра обобщённого вида,
является обобщённым, а всё остальное является определенным (не обобщённым).

Например, объявление *обобщённой функции* `foo` принимающей переменная `T` любого вида:

```rust,ignore
fn foo<T>(arg: T) { ... }
```

Поскольку `T` был объявлен как обобщённый вид, посредством `<T>`, он считается обобщённым
когда используется как `(arg: T)`. Это работает даже если `T` был определён как `стопка`.

Пример ниже отображает правила написания в действии:

```rust,editable
// Определенный вид `A`.
struct A;

// В определении вида `Single` первому использованию `A` не предшествует `<A>`.
// Поэтому `Single` имеет определенный вид, и `A` определена выше.
struct Single(A);
//            ^ Здесь `A` в первый раз используется в `Single`.

// В данном примере, `<T>` предшествует первому использованию `T`,
// поэтому `SingleGen` является обобщённым видом.
// Поскольку вид параметра `T` является обобщённым, он может быть чем угодно, включая
// определенный вид `A`, определённый выше.
struct SingleGen<T>(T);

fn main() {
    // `Single` имеет определенный вид и явно принимает параметр `A`.
    let _s = Single(A);

    // Создаём переменную `_char` вида `SingleGen<char>`
    // и присваиваем ей значение `SingleGen('a')`.
    // В примере ниже, вид параметра `SingleGen` явно определён.
    let _char: SingleGen<char> = SingleGen('a');

    // Здесь, `SingleGen` также может иметь неявно определённый параметр вида:
    let _t    = SingleGen(A); // Используется стопка `A`, объявленная выше.
    let _i32  = SingleGen(6); // Используется `i32`.
    let _char = SingleGen('a'); // Используется `char`.
}
```

### Смотрите также:

[`Стопки` ](custom_types/structs.md)
