# macro_rules!

Ржавчина предоставляет мощную систему макросов, которая позволяет
использовать метапрограммирование. Как вы могли видеть в предыдущих главах,
макросы выглядят как функции, но их имя заканчивается восклицательным знаком (`!`).
Вместо вызова функции, макросы расширяются в исходная рукопись[,] который впоследствии
собирается с остальной частью программы.
Однако, в отличие от макросов на C и других языках, макросы Ржавчина расширяются
в абстрактные синтаксические деревья, а не в подстановку строк,
поэтому Вы не получаете неожиданных ошибок предпочтения действий.

Макросы создаются с помощью макроса `macro_rules!`

```rust,editable
// Этот простой макрос называется `say_hello`.
macro_rules! say_hello {
    // `()` указывает, что макрос не принимает переменных.
    () => (
        // Макрос будет раскрываться с содержимым этого раздела.
        println!("Hello!");
    )
}

fn main() {
    // Этот вызов будет раскрыт в рукописи `println!("Hello");`
    say_hello!()
}
```

Так почему же макросы полезны?

1. Не повторяйтесь. Есть много случаев, когда вам может понадобиться подобная
    возможности в нескольких местах, но с различными видами. Чаще всего написание
    макроса - это полезный способ избежать повторения рукописи. (Подробнее об этом позже)

2. Предметно-ориентированные языки. Макросы позволяют определить особый правила написания для
    определенной цели. (Подробнее об этом позже)

3. Вариативные внешние оболочки. Иногда требуется определить внешняя оболочка, которая
    имеет переменное количество переменных. Пример: `println!`, который может принять любое
    количество переменных в зависимости от строки вида. (Подробнее об этом позже)
