# Анонимность видов

Замыкания временно захватывают переменные из окружающих областей видимости.
Имеет ли это какие-либо последствия? Конечно. Как видите, использование
замыкания в переменнойх функции требует [обобщённых видов](generics.html) из-за
особенностей реализации замыканий:

```rust
// `F` должен быть обобщённым видом.
fn apply<F>(f: F) where
    F: FnOnce() {
    f();
}
```

Во время определения замыкания сборщик неявно создаёт новую анонимную стопку для хранения захваченных переменных, тем временем реализуя возможности для некого неизвестного вида с помощью одного из сущностей: `Fn`,
`FnMut`, или `FnOnce`. Этот вид присваивается переменной, которая хранится до
самого вызова замыкания.

Так как этот новый вид заранее неизвестен, любое его использование в функции
потребует обобщённых видов. Тем не менее, неограниченный параметр вида `<T>`
по прежнему будет неоднозначным и недопустим. Таким образом, ограничение по
одному из сущностей: `Fn`, `FnMut`, или `FnOnce` (которые он реализует) необходимо
для использования этого вида.

```rust,editable
// `F` должен реализовать `Fn` для замыкания, которое
// ничего не принимает и не возвращает - именно то,
// что нужно для `print`.
fn apply<F>(f: F) where
    F: Fn() {
    f();
}

fn main() {
    let x = 7;

    // Захватываем `x` в анонимный вид и реализуем
    // `Fn` для него. Сохраняем его как `print`.
    let print = || println!("{}", x);

    apply(print);
}
```

### Смотрите также:

[Подробный разбор](https://huonw.github.io/blog/2015/05/finding-closure-in-rust/), [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html), [`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html),
и [`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html)
